#!/usr/bin/env generic

class ConditionResult {
    init() {
        this.spots_done = 0;
        this.spots_open = [];
    }
}

class TicTacToe {
    init() {
        this.board = ["0", "1", "2", "3", "4", "5", "6", "7", "8"];
        this.win_conditions = [
            [0, 1, 2], [3, 4, 5], [6, 7, 8], # Rows
            [0, 3, 6], [1, 4, 7], [2, 5, 8], # Cols
            [0, 4, 8], [2, 4, 6] # Diagonals
        ];
        this.player_markers = ["X", "O"];
        this.ai_opponent = false;
        this.ai_marker = "X";
        this.ai_strength = 1;
    }

    swap_player(player) {
        if player == "X" {
            return "O";
        }
        return "X";
    }

    show_board() {
        var line_separator = "---------------";
        print(line_separator);
        var side_length = 3;
        for (var row = 0; row < side_length; row += 1) {
            for (var col = 0; col < side_length; col += 1) {
                print("| " + str(this.board[(row * side_length) + col] + " |"), "");
            }
            print("");
            print(line_separator);
        }
    }

    check_win_condition(player, win_condition) {
        var result = ConditionResult();
        var spot;
        for (var i = 0; i < len(win_condition); i += 1) {
            spot = win_condition[i];
            if this.board[spot] == player {
                result.spots_done += 1;
            }
            if this.player_markers.contains(this.board[spot]) {
                result.spots_open.append(spot);
            }
        }
        return result;
    }

    is_player_win(player) {
        var result;
        for (var i = 0; i < len(this.win_conditions); i += 1) {
            result = this.check_win_condition(player, this.win_conditions[i]);
            if result.spots_done == 3 {
                return true;
            }
        }
        return false;
    }

    board_filled() {
        for (var spot = 0; spot < len(this.board); spot += 1) {
            unless this.player_markers.contains(this.board[spot]) {
                return false;
            }
        }
        return true;
    }

    fix_spot(spot, player) {
        if spot < 0 or spot > 8 {
            print("ERROR: Spot has to be in range [0-8]!");
            return false;
        }
        if this.player_markers.contains(this.board[spot]) {
            print("ERROR: Spot " + spot + " is already occupied!");
            return false;
        }
        this.board[spot] = player;
        return true;
    }

    player_turn(player) {
        print("Player " + player + " turn.");
        this.show_board();

        var spot;
        var valid_input = false;
        var user_input;
        until valid_input {
            user_input = input("Where to make your next move? [0-8]");
            unless is_int(user_input) {
                print("ERROR: Input must be a valid integer!");
                continue;
            }
            if this.fix_spot(int(user_input), player) {
                valid_input = true;
            }
        }
    }

    initialize_game() {
        return;
    }

    play() {
        var player = "X";

        while true {
            this.player_turn(player);

            if this.is_player_win(player) {
                print("Player " + player + " wins the game!");
                break;
            }

            if this.board_filled() {
                print("Match Draw!");
                break;
            }

            player = this.swap_player(player);
        }

        this.show_board();
    }

}


var tictactoe = TicTacToe();
tictactoe.initialize_game();
tictactoe.play();
